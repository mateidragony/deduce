
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Full reference manual for the deduce language.">
    <meta name="keywords" content="Deduce, Proof, Programming">
    <meta name="author" content="Jeremy Siek">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deduce | Reference Manual</title>

    <!-- Social cards -->
    <meta property="og:url" content="https://jsiek.github.io/deduce/pages/reference.html" />
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="Deduce | Reference Manual" />
    <meta property="og:description" content="Full reference manual for the deduce language." />
    <meta property="og:site_name" content="Deduce">
    <meta property="og:image" content="https://jsiek.github.io/deduce/images/logo.svg" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Deduce | Reference Manual">
    <meta name="twitter:description" content="Full reference manual for the deduce language.">
    <meta name="twitter:image" content="https://jsiek.github.io/deduce/images/logo.svg">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../images/logo.svg">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Josefin+Slab:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">

    <!-- Font awesome -->
    <script src="https://kit.fontawesome.com/7005573326.js" crossorigin="anonymous"></script>

    <!-- My stylesheets -->
    <link rel="stylesheet" href="../css/normalize.css">
    <link id="stylesheet" rel="stylesheet" href="../css/style.css">
</head>

<body>

    <div class="container md reference">
        <deduce-nav>
            <!-- custom component defined in script.js -->
        </deduce-nav>
    <h1 id="reference-manual">Reference Manual</h1>
<p>This is a comprehensive reference for Deduce. It describes each
feature in alphabetical order by keyword. It gives the grammar rule
(syntax) and describes its meaning and/or how it is used in a proof.</p>
<p>In the grammar rules, an unquoted asterisk means zero-or more
repetitions of the grammar item that it follows.
The symbol ε means the empty string.
A vertical bar separates alternatives right-hand sides in a grammar rule.</p>
<h2 id="add">Add</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"+"&nbsp;term</code></div>
<p>The addition function for natural numbers is defined in <code class="inline">Nat.pf</code>
as follows.</p>
<div class="code-wrapper non-deduce"><code>function&nbsp;operator&nbsp;+(Nat,Nat)&nbsp;-&gt;&nbsp;Nat&nbsp;{<br>
&nbsp;&nbsp;operator&nbsp;+(0,&nbsp;m)&nbsp;=&nbsp;m<br>
&nbsp;&nbsp;operator&nbsp;+(suc(n),&nbsp;m)&nbsp;=&nbsp;suc(n&nbsp;+&nbsp;m)<br>
}</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_add_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="add-multiset">Add (Multiset)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"&#x2A04;"&nbsp;term<br>
term&nbsp;::=&nbsp;term&nbsp;"[+]"&nbsp;term</code></div>
<p>Addition on multisets is defined in <code class="inline">MultiSet.pf</code>.  The main theorem
about multiset addition is <code class="inline">cnt_sum</code>, which says that the count for
each item in <code class="inline">A ⨄ B</code> is the sum of (1) the count for that item in <code class="inline">A</code>
and (2) the count for that item in <code class="inline">B</code>.</p>
<div class="code-wrapper non-deduce"><code>cnt_sum:&nbsp;all&nbsp;T:type.&nbsp;all&nbsp;A:MultiSet&lt;T&gt;,&nbsp;B:MultiSet&lt;T&gt;,&nbsp;x:T.<br>
&nbsp;&nbsp;cnt(A&nbsp;&#x2A04;&nbsp;B)(x)&nbsp;=&nbsp;cnt(A)(x)&nbsp;+&nbsp;cnt(B)(x)</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_add_multiset_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="all-universal-quantifier">All (Universal Quantifier)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;"all"&nbsp;var_list&nbsp;"."&nbsp;formula</code></div>
<p>A formula of the form <code class="inline">all x1:T1,...,xn:Tn. P</code> is true
when <code class="inline">P</code> is true for all possible choices of <code class="inline">x1</code>...<code class="inline">xn</code>.</p>
<p>To prove an <code class="inline">all</code> formula, use <code class="inline">arbitrary</code> (see entry for
<a href="#arbitrary-forall-introduction" target="_self">Arbitrary</a>) or <code class="inline">induction</code> (see entry
for <a href="#induction" target="_self">Induction</a>). Induction is only allowed when the <code class="inline">all</code>
has a single variable, as in <code class="inline">all x:T. P</code>, and the type <code class="inline">T</code> must be a
union type.</p>
<div class="code-wrapper"><code id="reference_all_example_bool"><!-- Generated by codeUtils.js --></code></div>
<div class="code-wrapper"><code id="reference_all_example_intro"><!-- Generated by codeUtils.js --></code></div>
<p>A proof of <code class="inline">all x1:T1,...,xn:Tn. P</code> can be used to prove the
formula <code class="inline">P</code> where the <code class="inline">x1,...,xn</code> have been replaced by 
terms of your choice. Use square brackets to enclose your
comma-delimited choices.</p>
<div class="code-wrapper"><code id="reference_all_example_elim"><!-- Generated by codeUtils.js --></code></div>
<h2 id="and-logical-conjunction">And (logical conjunction)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;formula&nbsp;"and"&nbsp;formula</code></div>
<p>The formula <code class="inline">P and Q</code> is true when both <code class="inline">P</code> and <code class="inline">Q</code> are true.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_and_example"><!-- Generated by codeUtils.js --></code></div>
<p>Use comma to combine a proof of <code class="inline">P</code> and a proof of <code class="inline">Q</code> into a proof of
<code class="inline">P and Q</code>.</p>
<div class="code-wrapper"><code id="reference_and_example_intro"><!-- Generated by codeUtils.js --></code></div>
<p>A proof of <code class="inline">P and Q</code> can be used implicitly to prove <code class="inline">P</code> and to prove <code class="inline">Q</code>.</p>
<div class="code-wrapper"><code id="reference_and_example_elim"><!-- Generated by codeUtils.js --></code></div>
<h2 id="append">Append</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"++"&nbsp;term</code></div>
<p>The append function, i.e., <code class="inline">operator ++</code>, is defined in <code class="inline">List.pf</code> as follows.</p>
<div class="code-wrapper non-deduce"><code>function&nbsp;operator&nbsp;++&nbsp;&lt;E&gt;(List&lt;E&gt;,&nbsp;List&lt;E&gt;)&nbsp;-&gt;&nbsp;List&lt;E&gt;&nbsp;{<br>
&nbsp;&nbsp;operator&nbsp;++(empty,&nbsp;ys)&nbsp;=&nbsp;ys<br>
&nbsp;&nbsp;operator&nbsp;++(node(n,&nbsp;xs),&nbsp;ys)&nbsp;=&nbsp;node(n,&nbsp;xs&nbsp;++&nbsp;ys)<br>
}</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_append_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="apply-to-proof-modus-ponens">Apply-To Proof (Modus Ponens)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"apply"&nbsp;proof&nbsp;"to"&nbsp;proof</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>apply&nbsp;X&nbsp;to&nbsp;Y</code></div>
<p>is a proof of formula <code class="inline">Q</code> if <code class="inline">X</code> is a proof of <code class="inline">(if P then Q)</code>
and <code class="inline">Y</code> is a proof of <code class="inline">P</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_apply_to_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="arbitrary-forall-introduction">Arbitrary (Forall Introduction)</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"arbitrary"&nbsp;var_list</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>arbitrary&nbsp;x1:T1,&nbsp;...,&nbsp;xn:Tn<br>
X</code></div>
<p>is a proof of the formula <code class="inline">all x1:T1, ..., xn:Tn. P</code> if <code class="inline">X</code> is a proof of <code class="inline">P</code>.
The variables <code class="inline">x1</code>, ..., <code class="inline">xn</code> may appear in the formula <code class="inline">P</code> and the proof <code class="inline">X</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_arbitrary_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="assert-statement">Assert (Statement)</h2>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"assert"&nbsp;term</code></div>
<p>The <code class="inline">assert</code> statement evaluates a term and reports an error if the
result is <code class="inline">false</code>. For example, the following <code class="inline">assert</code> does nothing
because the term evaluates to <code class="inline">true</code>.</p>
<div class="code-wrapper"><code id="reference_assert_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="assume">Assume</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"assume"&nbsp;assumption<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"suppose"&nbsp;assumption</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>assume&nbsp;label:&nbsp;P<br>
X</code></div>
<p>is a proof of the formula <code class="inline">if P then Q</code> if <code class="inline">X</code> is a proof of <code class="inline">Q</code>.
The proof <code class="inline">X</code> may use the <code class="inline">label</code> as a proof of <code class="inline">P</code>
and it may also refer to the proof of <code class="inline">P</code> by writing <code class="inline">recall P</code>.</p>
<div class="code-wrapper"><code id="reference_assume_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="assumption-and-assumption-list">Assumption and Assumption List</h2>
<div class="code-wrapper non-deduce"><code>assumption&nbsp;::=&nbsp;identifier<br>
assumption&nbsp;::=&nbsp;identifier&nbsp;":"&nbsp;formula<br>
assumption&nbsp;::=&nbsp;":"&nbsp;formula<br>
<br>
<br>
<br>
assumption_list&nbsp;::=&nbsp;assumption<br>
assumption_list&nbsp;::=&nbsp;assumption&nbsp;","&nbsp;assumption_list</code></div>
<p>See the entry for <a href="#assume" target="_self">Assume</a> to see how assumptions are used.</p>
<h2 id="at-symbol">At Symbol <code class="inline">@</code></h2>
<p>See the entry for <a href="#instantiation-term" target="_self">Instantiation</a>.</p>
<h2 id="biconditional-if-and-only-if">Biconditional (if and only if)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;formula&nbsp;"⇔"&nbsp;formula<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;formula&nbsp;"&lt;=&gt;"&nbsp;formula<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;formula&nbsp;"iff"&nbsp;formula</code></div>
<p>The biconditional formula <code class="inline">P ⇔ Q</code> is syntactic sugar for
<code class="inline">(if P then Q) and (if Q then P)</code>.</p>
<h2 id="bool-type">Bool (Type)</h2>
<div class="code-wrapper non-deduce"><code>type&nbsp;::=&nbsp;"bool"</code></div>
<p>The type <code class="inline">bool</code> classifies the values <code class="inline">true</code> and <code class="inline">false</code>.
A formula is a term of type <code class="inline">bool</code>.</p>
<h2 id="braces-proof">Braces (Proof)</h2>
<div class="code-wrapper non-deduce"><code>proof&nbsp;::=&nbsp;"{"&nbsp;proof&nbsp;"}"</code></div>
<p>A proof may be surrounded in curly braces.</p>
<h2 id="call-term">Call (Term)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"("&nbsp;term_list&nbsp;")"</code></div>
<p>A term of the form <code class="inline">t0(t1, ..., tn)</code> calls the function indicated by
term <code class="inline">t0</code> on the arguments <code class="inline">t1</code>,...,<code class="inline">tn</code>.</p>
<div class="code-wrapper"><code id="reference_call_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="cases-disjunction-elimination">Cases (Disjunction Elimination)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"cases"&nbsp;proof&nbsp;case_list<br>
case_list&nbsp;::=&nbsp;case&nbsp;|&nbsp;case&nbsp;case_list<br>
case&nbsp;::=&nbsp;"case"&nbsp;identifier&nbsp;"{"&nbsp;proof&nbsp;"}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"case"&nbsp;identifier&nbsp;":"&nbsp;term&nbsp;"{"&nbsp;proof&nbsp;"}"</code></div>
<p>In Deduce, you can use an <code class="inline">or</code> fact by doing case analysis with the
<code class="inline">cases</code> statement. There is one <code class="inline">case</code> for each subformula of the
<code class="inline">or</code>. </p>
<p>In the following example, we prove that <code class="inline">x ≤ y or y &lt; x</code>
from the trichotomy law: <code class="inline">x &lt; y or x = y or y &lt; x</code>.</p>
<div class="code-wrapper non-deduce"><code>have&nbsp;tri:&nbsp;x&nbsp;&lt;&nbsp;y&nbsp;or&nbsp;x&nbsp;=&nbsp;y&nbsp;or&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;by&nbsp;trichotomy[x][y]<br>
cases&nbsp;tri<br>
case&nbsp;x_l_y:&nbsp;x&nbsp;&lt;&nbsp;y&nbsp;{<br>
&nbsp;&nbsp;have&nbsp;x_le_y:&nbsp;x&nbsp;&#x2264;&nbsp;y&nbsp;by&nbsp;apply&nbsp;less_implies_less_equal[x][y]&nbsp;to&nbsp;x_l_y<br>
&nbsp;&nbsp;conclude&nbsp;x&nbsp;&#x2264;&nbsp;y&nbsp;or&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;by&nbsp;x_le_y<br>
}<br>
case&nbsp;x_eq_y:&nbsp;x&nbsp;=&nbsp;y&nbsp;{<br>
&nbsp;&nbsp;have&nbsp;x_le_y:&nbsp;x&nbsp;&#x2264;&nbsp;y&nbsp;by<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffices&nbsp;y&nbsp;&#x2264;&nbsp;y&nbsp;&nbsp;by&nbsp;rewrite&nbsp;x_eq_y<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;less_equal_refl[y]<br>
&nbsp;&nbsp;conclude&nbsp;x&nbsp;&#x2264;&nbsp;y&nbsp;or&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;by&nbsp;x_le_y<br>
}<br>
case&nbsp;y_l_x:&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;{<br>
&nbsp;&nbsp;conclude&nbsp;x&nbsp;&#x2264;&nbsp;y&nbsp;or&nbsp;y&nbsp;&lt;&nbsp;x&nbsp;by&nbsp;y_l_x<br>
}</code></div>
<h2 id="choose-proof">Choose (Proof)</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"choose"&nbsp;term_list</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>choose&nbsp;e1,...,en<br>
X</code></div>
<p>is a proof of the formula <code class="inline">some x1,...xn. P</code>
if <code class="inline">X</code> is a proof of formula <code class="inline">P</code> where the <code class="inline">x</code>'s replaced by the <code class="inline">e</code>'s.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_choose_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="comma-logical-and-introduction">Comma (Logical And Introduction)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;proof&nbsp;","&nbsp;proof</code></div>
<p>See the entry for And (logical conjunction).</p>
<h2 id="compose-functions">Compose (Functions)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"&#x2218;"&nbsp;term&nbsp;|&nbsp;term&nbsp;"[o]"&nbsp;term</code></div>
<p>The composition of two functions <code class="inline">g ∘ f</code> is defined in <code class="inline">Maps.pf</code>
so that <code class="inline">(g ∘ f)(x) = g(f(x))</code>.</p>
<p>Example:</p>
<p>Applying the successor function <code class="inline">suc</code> (add 1) to <code class="inline">3</code> yields <code class="inline">5</code>.</p>
<div class="code-wrapper"><code id="reference_compose_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="conclude-proof">Conclude (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"conclude"&nbsp;formula&nbsp;"by"&nbsp;proof</code></div>
<p>This proof statement is useful when you wish to emphasize the end of a
proof by stating the formula that is being proved.</p>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>conclude&nbsp;P&nbsp;by&nbsp;X</code></div>
<p>is a proof of formula <code class="inline">P</code> if <code class="inline">X</code> is a proof of <code class="inline">P</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_conclude_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="conclusion-proof">Conclusion (Proof)</h2>
<p>The last statement in a proof (the <code class="inline">conclusion</code> symbol in the grammar)
must be one of the following:</p>
<ul>
<li><a href="#cases-disjunction-elimination" target="_self">Cases</a></li>
<li><a href="#comma-logical-and-introduction" target="_self">Comma (Logical-And Introduction)</a></li>
<li><a href="#conclude-proof" target="_self">Conclude</a></li>
<li><a href="#conjunct" target="_self">Conjunct</a></li>
<li><a href="#definition-proof" target="_self">Definition</a></li>
<li><a href="#definition-in-proof" target="_self">Definition-In</a></li>
<li><a href="#definition-and-replace-proof" target="_self">Definition and Replace</a></li>
<li><a href="#definition-and-rewrite-proof" target="_self">Definition and Rewrite</a></li>
<li><a href="#equations" target="_self">Equations</a></li>
<li><a href="#evaluate-proof" target="_self">Evaluate</a></li>
<li><a href="#evaluate-in-proof" target="_self">Evaluate-In</a></li>
<li><a href="#help-proof" target="_self">Help</a></li>
<li><a href="#identifier" target="_self">Identifier</a></li>
<li><a href="#induction" target="_self">Induction</a></li>
<li><a href="#instantiation-proof" target="_self">Instantiation</a></li>
<li><a href="#period-proof-of-true" target="_self">Period</a></li>
<li><a href="#question-mark-proof" target="_self">Question Mark</a></li>
<li><a href="#recall-proof" target="_self">Recall</a></li>
<li><a href="#replace-proof" target="_self">Replace</a></li>
<li><a href="#rewrite-proof" target="_self">Rewrite</a></li>
<li><a href="#sorry-proof" target="_self">Sorry</a></li>
<li><a href="#switch-proof" target="_self">Switch</a></li>
<li><a href="#symmetric-proof" target="_self">Symmetric</a></li>
<li><a href="#transitive-proof" target="_self">Transitive</a></li>
</ul>
<h2 id="conjunct">Conjunct</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"conjunct"&nbsp;number&nbsp;"of"&nbsp;proof&nbsp;</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>conjunct&nbsp;n&nbsp;of&nbsp;X</code></div>
<p>is a proof of <code class="inline">Pn</code> if <code class="inline">X</code> is a proof of <code class="inline">P1 and ... and Pk</code>
and 1 ≤ n ≤ k.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_conjunct_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="contradiction">Contradiction</h2>
<p>During a proof, one sometimes encounters assumptions that contradict
each other. In these situations, you can prove <code class="inline">false</code> and from that,
anything else (the Principle of Explosion). Here are two ways to prove
<code class="inline">false</code> from contradictions.</p>
<p>(1) If you have a proof <code class="inline">X</code> of an equality with different constructors
on the left and right-hand side, such as</p>
<div class="code-wrapper non-deduce"><code>have&nbsp;X:&nbsp;empty&nbsp;=&nbsp;node(3,&nbsp;empty)&nbsp;by&nbsp;...</code></div>
<p>or</p>
<div class="code-wrapper non-deduce"><code>have&nbsp;X:&nbsp;0&nbsp;=&nbsp;1&nbsp;by&nbsp;...</code></div>
<p>then you can implicitly use <code class="inline">X</code> to prove <code class="inline">false</code>:</p>
<div class="code-wrapper non-deduce"><code>conclude&nbsp;false&nbsp;by&nbsp;X</code></div>
<p>(2) If you have a proof <code class="inline">X</code> of <code class="inline">P</code> and a proof <code class="inline">Y</code> of <code class="inline">not P</code>,
then you can prove <code class="inline">false</code> using <code class="inline">apply</code>-<code class="inline">to</code>. (Because
<code class="inline">not P</code> is shorthand for <code class="inline">if P then false</code>.)</p>
<div class="code-wrapper non-deduce"><code>have&nbsp;X:&nbsp;P&nbsp;by&nbsp;...<br>
have&nbsp;Y:&nbsp;not&nbsp;P&nbsp;by&nbsp;...<br>
conclude&nbsp;false&nbsp;by&nbsp;apply&nbsp;Y&nbsp;to&nbsp;X</code></div>
<h2 id="define-statement">Define (Statement)</h2>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"define"&nbsp;ident&nbsp;":"&nbsp;type&nbsp;"="&nbsp;term<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"define"&nbsp;ident&nbsp;"="&nbsp;term</code></div>
<p>The <code class="inline">define</code> feature of Deduce associates a name with a value.  For
example, the following definitions associate the name <code class="inline">five</code> with the
natural number <code class="inline">5</code>, and the name <code class="inline">six</code> with the natural number <code class="inline">6</code>.</p>
<div class="code-wrapper"><code id="reference_define_example"><!-- Generated by codeUtils.js --></code></div>
<p>Optionally, the type can be specified after the name, following a
colon.  In the above, <code class="inline">six</code> holds a natural number, so its type is
<code class="inline">Nat</code>.</p>
<h2 id="define-term">Define (Term)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"define"&nbsp;identifier&nbsp;"="&nbsp;term&nbsp;";"&nbsp;term</code></div>
<p>This associates a name with a term for use in the term after the semicolon.</p>
<div class="code-wrapper"><code id="reference_define_term_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="define-proof">Define (Proof)</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"define"&nbsp;identifier&nbsp;"="&nbsp;term&nbsp;&nbsp;proof</code></div>
<p>This associates a name with a term for use in the following proof.
(Note: there is no semicolon after the term when using <code class="inline">define</code> in a proof.)</p>
<div class="code-wrapper"><code id="reference_define_proof_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="definition-proof">Definition (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"definition"&nbsp;identifier_list_bar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;added&nbsp;in&nbsp;version&nbsp;1.2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"definition"&nbsp;"{"&nbsp;identifier_list&nbsp;"}"</code></div>
<p>In the current goal formula, replace the occurrences of the specified
names with their definitions and then check whether the formula has
simplified to <code class="inline">true</code>. If a definition is recursive, only one expansion
is performed per time the definition's name is mentioned in the
list. If one of the specified names does not appear in the goal
formula, Deduce signals an error.</p>
<div class="code-wrapper"><code id="reference_definition_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="definition-and-replace-proof">Definition and Replace (Proof)</h2>
<p>(This feature was added in Deduce version 1.1.)</p>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"definition"&nbsp;"{"&nbsp;identifier_list&nbsp;"}"&nbsp;"and"&nbsp;"replace"&nbsp;proof_list<br>
conclusion&nbsp;::=&nbsp;"definition"&nbsp;identifier_list_bar&nbsp;"and"&nbsp;"replace"&nbsp;proof_list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;added&nbsp;in&nbsp;version&nbsp;1.2</code></div>
<p>An alternative syntax for <a href="#definition-and-rewrite-proof" target="_self">Definition and Rewrite</a>.</p>
<h2 id="definition-and-rewrite-proof">Definition and Rewrite (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"definition"&nbsp;"{"&nbsp;identifier_list&nbsp;"}"&nbsp;"and"&nbsp;"rewrite"&nbsp;proof_list<br>
conclusion&nbsp;::=&nbsp;"definition"&nbsp;identifier_list_bar&nbsp;"and"&nbsp;"rewrite"&nbsp;proof_list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;added&nbsp;in&nbsp;version&nbsp;1.2</code></div>
<p>Apply the specified definitions to the current goal
(see <a href="#definition-proof" target="_self">Definition (Proof)</a>), then the specified rewrites
(see <a href="#rewrite-proof" target="_self">Rewrite (Proof)</a>).  If this simplifies that formula
to <code class="inline">true</code>, then this statement proves the goal.  Otherwise, Deduce
signals an error.</p>
<h2 id="definition-in-proof">Definition-In (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"definition"&nbsp;"{"&nbsp;identifier_list&nbsp;"}"&nbsp;"in"&nbsp;proof<br>
conclusion&nbsp;::=&nbsp;"definition"&nbsp;identifier_list_bar&nbsp;"in"&nbsp;proof&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;added&nbsp;in&nbsp;version&nbsp;1.2</code></div>
<p>In the formula of the given proof, replace the occurrences of the
specified names with their definitions, resulting in the formula that
is proved by this <code class="inline">definition</code>-<code class="inline">in</code> statement.  If a definition is
recursive, only one expansion is performed per time the definition's
name is mentioned in the list. If one of the specified names does not
appear in the formula, Deduce signals an error.</p>
<div class="code-wrapper"><code id="reference_definition_in_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="divide">Divide</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"/"&nbsp;term</code></div>
<p>The division function for <code class="inline">Nat</code> and <code class="inline">Pos</code> is defined in <code class="inline">Nat.pf</code>.
The main theorem is <code class="inline">division_remainder</code> which states that</p>
<div class="code-wrapper non-deduce"><code>(n&nbsp;/&nbsp;m)&nbsp;&ast;&nbsp;pos2nat(m)&nbsp;+&nbsp;(n&nbsp;%&nbsp;m)&nbsp;=&nbsp;n</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_division_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="empty-set">Empty Set</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"&#x2205;"</code></div>
<p>The empty set <code class="inline">∅</code> does not contain any elements and is defined in
<code class="inline">Set.pf</code>.</p>
<h2 id="equal">Equal</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"="&nbsp;term</code></div>
<p>The formula <code class="inline">a = b</code> is true when the left-hand side and right-hand are
the same. </p>
<p>(In Deduce, there is no distinction between identity and deep equality
as there is in Java because there is no concept of identity in
Deduce.)</p>
<h2 id="equations">Equations</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"equations"&nbsp;equation&nbsp;equation_list<br>
equation&nbsp;::=&nbsp;term&nbsp;"="&nbsp;term&nbsp;"by"&nbsp;proof<br>
half_equation&nbsp;::=&nbsp;"..."&nbsp;"="&nbsp;term&nbsp;"by"&nbsp;proof<br>
equation_list&nbsp;::=&nbsp;half_equation<br>
equation_list&nbsp;::=&nbsp;half_equation&nbsp;equation_list<br>
equation_list&nbsp;::=&nbsp;"$"&nbsp;equation&nbsp;equation_list</code></div>
<p>Combining a sequence of equations using <code class="inline">transitive</code> is quite common,
so Deduce provides <code class="inline">equations</code> to streamline this process.  After the
first equation, the left-hand side of each equation is written as
<code class="inline">...</code> because it is just a repetition of the right-hand side of the
previous equation.</p>
<p>When using <code class="inline">replace</code> for one of the reasoning steps in <code class="inline">equations</code>,
the replacement is, by default, applied to the left-hand side of the
equation (and not the right-hand side). However, if you would like to
apply a replacement to the right-hand side, use hash marks (<code class="inline">#</code>)
around the region of the right-hand side that you want to change.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_equations_example"><!-- Generated by codeUtils.js --></code></div>
<p>The hash marks can also be used to control where Deduce applies a
<code class="inline">definition</code>. In the following example, the hash marks tell Deduce to
unfold the definition of <code class="inline">length</code> in the right-hand side of the second
equation.</p>
<div class="code-wrapper"><code id="reference_equations_def_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="evaluate-proof">Evaluate (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"evaluate"</code></div>
<p>The <code class="inline">evaluate</code> proof method simplifies the goal formula by applying all
definitions. It succeeds if the formula is simplified to <code class="inline">true</code>.</p>
<h2 id="evaluate-in-proof">Evaluate-In (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"evaluate"&nbsp;"in"&nbsp;proof</code></div>
<p>The <code class="inline">evaluate</code>-<code class="inline">in</code> proof method simplifies the formula of the given
proof by applying all definitions, producing a proof of the simplified
formula.</p>
<h2 id="extensionality">Extensionality</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"extensionality"</code></div>
<p>To prove that two functions are equal, it is sufficient to prove that
they always produce equal outputs given equal inputs.</p>
<div class="code-wrapper"><code id="reference_extensionality_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="false">False</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;"false"</code></div>
<p>One can prove <code class="inline">false</code> when there are assumptions that contradict
each other, such as <code class="inline">x = 0</code> and <code class="inline">x = 1</code>, or <code class="inline">not P</code> and <code class="inline">P</code>.</p>
<p>A proof of <code class="inline">false</code> can be used to prove anything else!
(This is known as the Principle of Explosion.)</p>
<h2 id="formula">Formula</h2>
<p>A formula is any term of type <code class="inline">bool</code>.</p>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term</code></div>
<h2 id="function-term">Function (Term)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"fun"&nbsp;var_list&nbsp;"{"&nbsp;term&nbsp;"}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"&#x03BB;"&nbsp;var_list&nbsp;"{"&nbsp;term&nbsp;"}"</code></div>
<p>Functions are created with a <code class="inline">fun</code> expression.  Their syntax starts with
<code class="inline">fun</code>, followed by parameter names and their types, then the body of the
function enclosed in braces.  For example, the following defines a
function for computing the area of a rectangle.</p>
<div class="code-wrapper"><code id="reference_function_term_example"><!-- Generated by codeUtils.js --></code></div>
<p>To call a function, apply it to the appropriate number and type of
arguments.</p>
<div class="code-wrapper"><code id="reference_print_area"><!-- Generated by codeUtils.js --></code></div>
<p>The output is <code class="inline">12</code>.</p>
<p>To add type parameters to a function (to make it generic), see
<a href="#generic-function-term" target="_self">Generic Function</a>.</p>
<h2 id="fun-statement">Fun (Statement)</h2>
<p>(This feature was added in Deduce version 1.1.)</p>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"fun"&nbsp;ident&nbsp;type_params_opt&nbsp;"("&nbsp;var_list&nbsp;")"&nbsp;"{"&nbsp;term&nbsp;"}"</code></div>
<p>The <code class="inline">fun</code> statement is for defining a function (non-recursive).
The function begins with the <code class="inline">fun</code> keyword, followed by 
the type parameters enclosed in <code class="inline">&lt;</code> and <code class="inline">&gt;</code> (if generic),
then the parameter list enclosed in <code class="inline">(</code> and <code class="inline">)</code>, and finally
the body of the function enclosed in <code class="inline">{</code> and <code class="inline">}</code>.</p>
<div class="code-wrapper"><code id="reference_fun_exchange_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="function-statement">Function (Statement)</h2>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"function"&nbsp;identifier&nbsp;type_params_opt&nbsp;"("&nbsp;type_list&nbsp;")"&nbsp;"-&gt;"&nbsp;type&nbsp;"{"&nbsp;fun_case&ast;&nbsp;"}"<br>
fun_case&nbsp;::=&nbsp;identifier&nbsp;"("&nbsp;pattern_list&nbsp;")"&nbsp;"="&nbsp;term</code></div>
<p>Alternate syntax in version 1.1 starts with <code class="inline">recursive</code> keyword:</p>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"recursive"&nbsp;identifier&nbsp;type_params_opt&nbsp;"("&nbsp;type_list&nbsp;")"&nbsp;"-&gt;"&nbsp;type&nbsp;"{"&nbsp;fun_case&ast;&nbsp;"}"</code></div>
<p>See <a href="#recursive-function-statement" target="_self">Recursive Function (Statement)</a></p>
<h2 id="function-type">Function Type</h2>
<div class="code-wrapper non-deduce"><code>type&nbsp;::=&nbsp;"fn"&nbsp;type_params_opt&nbsp;type_list&nbsp;"-&gt;"&nbsp;type</code></div>
<p>A function type classifies a function. This includes both recursive
functions (<code class="inline">function</code>) and anonymous functions (<code class="inline">fun</code> or <code class="inline">λ</code>).  If the
function is generic, its function type includes type parameters
enclosed in <code class="inline">&lt;</code> and <code class="inline">&gt;</code>.</p>
<h2 id="generic-formula">Generic (Formula)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;"&lt;"&nbsp;identifier_list&nbsp;"&gt;"&nbsp;formula</code></div>
<p>This parametrizes a formula by a list of type parameters.  For
example, the following formula states that if the length of a list is
0, then the list must be empty. The type parameter <code class="inline">&lt;T&gt;</code> means that
this formula applies to lists with any element type.</p>
<div class="code-wrapper non-deduce"><code>&lt;T&gt;&nbsp;all&nbsp;xs:List&lt;T&gt;.&nbsp;if&nbsp;length(xs)&nbsp;=&nbsp;0&nbsp;then&nbsp;xs&nbsp;=&nbsp;empty</code></div>
<h2 id="generic-term">Generic (Term)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"generic"&nbsp;identifier_list&nbsp;"{"&nbsp;term&nbsp;"}"</code></div>
<p>A term of the form</p>
<div class="code-wrapper non-deduce"><code>generic&nbsp;T1,&nbsp;...,&nbsp;Tn&nbsp;{&nbsp;X&nbsp;}</code></div>
<p>produces a generic function with type parameters 
<code class="inline">T1</code>, ..., <code class="inline">Tn</code>, if term <code class="inline">X</code> produces a function
(e.g., using <code class="inline">fun</code>).</p>
<p>An example use of <code class="inline">generic</code> is in <code class="inline">Maps.pf</code>, in the
definition of function composition.</p>
<div class="code-wrapper"><code id="reference_generic_example"><!-- Generated by codeUtils.js --></code></div>
<p>Generic recursive functions can be defined using the <code class="inline">function</code>
statement (see <a href="#function-statement" target="_self">Function</a>).</p>
<h2 id="generic-function-term">Generic Function (Term)</h2>
<p>(This feature was added in Deduce version 1.1.)</p>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"fun"&nbsp;type_params_opt&nbsp;var_list&nbsp;"{"&nbsp;term&nbsp;"}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"&#x03BB;"&nbsp;type_params_opt&nbsp;var_list&nbsp;"{"&nbsp;term&nbsp;"}"</code></div>
<p>To make a <a href="#function-term" target="_self">Function</a> generic, add type parameters surrounded
by <code class="inline">&lt;</code> and <code class="inline">&gt;</code>. For example, the following function declares two
type parameters with the syntax <code class="inline">&lt;T, U&gt;</code>.</p>
<div class="code-wrapper"><code id="reference_generic_fun_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="given">Given</h2>
<p>An assumption or fact that is already proved.</p>
<h2 id="greater-than">Greater-Than</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"&gt;"&nbsp;term</code></div>
<p>The greater-than operator on natural numbers is defined in <code class="inline">Nat.pf</code>
and is defined in terms of less-than as follows</p>
<div class="code-wrapper non-deduce"><code>x&nbsp;&gt;&nbsp;y&nbsp;=&nbsp;y&nbsp;&lt;&nbsp;x</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_greater_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="greater-than-or-equal">Greater-Than or Equal</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"&#x2265;"&nbsp;term<br>
formula&nbsp;::=&nbsp;term&nbsp;"&gt;="&nbsp;term</code></div>
<p>The greater-than-or-equal operator on natural numbers is defined in <code class="inline">Nat.pf</code>
and is defined in terms of less-than-or-equal as follows</p>
<div class="code-wrapper non-deduce"><code>x&nbsp;&#x2265;&nbsp;y&nbsp;=&nbsp;y&nbsp;&#x2264;&nbsp;x</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_greater_equal_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="have-proof-statement">Have (Proof Statement)</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"have"&nbsp;identifier&nbsp;":"&nbsp;term&nbsp;"by"&nbsp;proof&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"have"&nbsp;":"&nbsp;term&nbsp;"by"&nbsp;proof&nbsp;</code></div>
<p>Use <code class="inline">have</code> to prove a formula that may help you later to prove the
goal.</p>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>have&nbsp;label:&nbsp;P&nbsp;by&nbsp;X<br>
Y</code></div>
<p>is a proof of <code class="inline">Q</code> as long as <code class="inline">Y</code> is a proof of <code class="inline">Q</code> and <code class="inline">X</code> is a proof of <code class="inline">P</code>.</p>
<p>Inside the proof <code class="inline">X</code> the goal changes to <code class="inline">P</code>.</p>
<p>After the <code class="inline">have</code> statement, the formula <code class="inline">P</code> becomes a given and can be
used inside the proof <code class="inline">Y</code>.</p>
<h2 id="help-proof">Help (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"help"&nbsp;proof</code></div>
<p>This halts Deduce and prints advice regarding how to use the formula
of the supplied proof. Typically the supplied proof is the label for a
given.</p>
<h2 id="identifier">Identifier</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;identifier<br>
formula&nbsp;::=&nbsp;identifier<br>
conclusion&nbsp;::=&nbsp;identifier</code></div>
<p>Identifiers are used in Deduce to give names to functions and values and
to label theorems and facts.</p>
<p>An identifier is a sequence of characters that starts with an upper or
lower-case letter or an underscore, and is followed by letters,
digits, or the special characters <code class="inline">!</code>, <code class="inline">?</code>, and <code class="inline">'</code>.  An identifier
can also be an operator, which starts with the keyword
<code class="inline">operator</code> and is then followed by one of the following operators:
<code class="inline">+</code>, <code class="inline">-</code>, <code class="inline">*</code>, <code class="inline">/</code>, <code class="inline">%</code>, <code class="inline">=</code>, <code class="inline">≠</code>, <code class="inline">/=</code>, <code class="inline">&lt;</code>, <code class="inline">≤</code>, <code class="inline">&lt;=</code>, <code class="inline">≥</code>, <code class="inline">&gt;=</code>
<code class="inline">++</code>, <code class="inline">∩</code>, <code class="inline">&</code>, <code class="inline">∈</code>, <code class="inline">in</code>, <code class="inline">∪</code>, <code class="inline">|</code>, <code class="inline">⨄</code>, <code class="inline">.+.</code>, <code class="inline">⊆</code>, <code class="inline">(=</code>, <code class="inline">∘</code>, <code class="inline">.o.</code>.</p>
<h2 id="identifier-list">Identifier List</h2>
<p>A comma-separated sequence of identifiers.</p>
<div class="code-wrapper non-deduce"><code>identifier_list&nbsp;::=&nbsp;identifier<br>
identifier_list&nbsp;::=&nbsp;identifier&nbsp;","&nbsp;identifier_list</code></div>
<h2 id="identifier-list-bar">Identifier List Bar</h2>
<p>(This feature was added in Deduce version 1.2.)</p>
<p>A bar-separated sequence of identifiers. If an identifier is preceded
by a number and the multiplication sign, then the identifier is
repeated. (e.g. to make a definition expand recursively more than
once.)</p>
<div class="code-wrapper non-deduce"><code>identifier_list_bar&nbsp;::=&nbsp;identifier<br>
identifier_list_bar&nbsp;::=&nbsp;natural_number&nbsp;"&ast;"&nbsp;identifier<br>
identifier_list_bar&nbsp;::=&nbsp;identifier&nbsp;"|"&nbsp;identifier_list_bar<br>
identifier_list_bar&nbsp;::=&nbsp;natural_number&nbsp;"&ast;"&nbsp;identifier&nbsp;"|"&nbsp;identifier_list_bar</code></div>
<h2 id="if-and-only-if-iff">If and only if (iff)</h2>
<p>See the entry for <a href="#biconditional-if-and-only-if" target="_self">Biconditional</a>.</p>
<h2 id="if-then-conditional-formula">If Then (Conditional Formula)</h2>
<p>A formula <code class="inline">if P then Q</code> is true when both <code class="inline">P</code> and <code class="inline">Q</code> are true and it
is true when <code class="inline">P</code> is false.</p>
<p>To prove a conditional formula, use <code class="inline">assume</code>. (See the entry for <a href="#assume" target="_self">Assume</a>.)</p>
<p>To use a given that is a conditional formula, use <code class="inline">apply</code>-<code class="inline">to</code>.
(See the entry for <a href="#apply-to-proof-modus-ponens" target="_self">Apply-To</a>.)</p>
<h2 id="if-then-else-term">If Then Else (Term)</h2>
<p>A term of the form</p>
<div class="code-wrapper non-deduce"><code>if&nbsp;a&nbsp;then&nbsp;b&nbsp;else&nbsp;c</code></div>
<p>is equal to <code class="inline">b</code> when <code class="inline">a</code> is true and equal to <code class="inline">c</code> when <code class="inline">a</code> is false.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_if_then_else_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="import-statement">Import (Statement)</h2>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"import"&nbsp;identifier</code></div>
<p>Import all of the definitions and theorems from the specified file
(without the file extension).</p>
<h2 id="in-set-membership">In (Set Membership)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"&#x2208;"&nbsp;term<br>
formula&nbsp;::=&nbsp;term&nbsp;"in"&nbsp;term</code></div>
<p>The formula <code class="inline">x ∈ S</code> is true when element <code class="inline">x</code> is contained in the set <code class="inline">S</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_membership_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="induction">Induction</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"induction"&nbsp;type&nbsp;ind_case&ast;<br>
ind_case&nbsp;::=&nbsp;"case"&nbsp;pattern&nbsp;"{"&nbsp;proof&nbsp;"}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"case"&nbsp;pattern&nbsp;"assume"&nbsp;assumption_list&nbsp;"{"&nbsp;proof&nbsp;"}"</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>induction&nbsp;T<br>
case&nbsp;c1(e11,...,e1k)&nbsp;assume&nbsp;IH1,&nbsp;...&nbsp;{&nbsp;X1&nbsp;}<br>
...<br>
case&nbsp;cn(en1,...,enj)&nbsp;assume&nbsp;IH1,&nbsp;...&nbsp;{&nbsp;Xn&nbsp;}</code></div>
<p>is a proof of the formula <code class="inline">all x:T. P</code>
if each <code class="inline">Xi</code> is a proof of <code class="inline">P</code> where <code class="inline">x</code> is replaced
by <code class="inline">ci(ei1,...,eij)</code>. The type <code class="inline">T</code> must be a union type.
Each proof <code class="inline">Xi</code> may use its induction
hypotheses <code class="inline">IH1, ...</code>. For each term <code class="inline">ein</code> whose type is <code class="inline">T</code>
(so it is recursive), the induction hypothesis is
the formula <code class="inline">P</code> with <code class="inline">x</code> replaced by the constructor argument <code class="inline">ein</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_induction_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="injective-proof">Injective (Proof)</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"injective"&nbsp;term&nbsp;proof</code></div>
<p>The <code class="inline">injective</code> proof rule allows you to conclude that the inputs to a
constructor are equal if the outputs are equal. For example,
if <code class="inline">suc(x) = suc(y)</code> then <code class="inline">x = y</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_injective_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="instantiation-proof">Instantiation (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;proof&nbsp;'&lt;'&nbsp;type_list&nbsp;'&gt;'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;proof&nbsp;'['&nbsp;term_list&nbsp;']'</code></div>
<p>Use square brackets <code class="inline">[</code> and <code class="inline">]</code> to instantiate an <code class="inline">all</code> formula with 
terms and use angle brackets <code class="inline">&lt;</code> and <code class="inline">&gt;</code> to instantiate an <code class="inline">all</code>
formula with types.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_instantiate_proof_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="instantiation-term">Instantiation (Term)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;@&nbsp;term&nbsp;'&lt;'&nbsp;type_list&nbsp;'&gt;'</code></div>
<p>Instantiates a generic function or constructor, replaces its type
parameters with the given type arguments.</p>
<div class="code-wrapper"><code id="reference_instantiate_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="intersection">Intersection</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"&#x2229;"&nbsp;term<br>
term&nbsp;::=&nbsp;term&nbsp;"&"&nbsp;term</code></div>
<p>Set intersection is defined in <code class="inline">Set.pf</code>.
The intersection of sets <code class="inline">A</code> and <code class="inline">B</code>, written <code class="inline">A ∩ B</code>,
contains the items that occur both sets.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_intersect_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="less-than">Less-Than</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"&lt;"&nbsp;term</code></div>
<p>The less-than operator on natural numbers is defined in <code class="inline">Nat.pf</code>
as follows.</p>
<div class="code-wrapper non-deduce"><code>x&nbsp;&lt;&nbsp;y&nbsp;=&nbsp;suc(x)&nbsp;&#x2264;&nbsp;y</code></div>
<p>To find theorems about the less-than operator in <code class="inline">Nat.thm</code>, search for
theorems with <code class="inline">less</code> in the name.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_less_than_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="less-than-or-equal">Less-Than or Equal</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"&#x2264;"&nbsp;term<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;term&nbsp;"&lt;="&nbsp;term</code></div>
<p>The less-than-or-equal operator on natural numbers is defined in <code class="inline">Nat.pf</code>
as follows.</p>
<div class="code-wrapper non-deduce"><code>function&nbsp;operator&nbsp;&#x2264;(Nat,Nat)&nbsp;-&gt;&nbsp;bool&nbsp;{<br>
&nbsp;&nbsp;operator&nbsp;&#x2264;(0,&nbsp;m)&nbsp;=&nbsp;true<br>
&nbsp;&nbsp;operator&nbsp;&#x2264;(suc(n'),&nbsp;m)&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;m&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;0&nbsp;{&nbsp;false&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;suc(m')&nbsp;{&nbsp;n'&nbsp;&#x2264;&nbsp;m'&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}</code></div>
<p>To find theorems about the less-than operator in <code class="inline">Nat.thm</code>, search for
theorems with <code class="inline">less_equal</code> in the name.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_less_equal_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="list-term">List (Term)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"["&nbsp;term_list&nbsp;"]"</code></div>
<p>Deduce treats <code class="inline">[t1,t2,...,tn]</code> as syntactic sugar for
<code class="inline">node(t1, node(t2, ... node(tn, empty)))</code>.</p>
<h2 id="list-type">List (Type)</h2>
<p>The <code class="inline">List</code> type represents a singly-linked list of items and is
defined in <code class="inline">List.pf</code> as follows.</p>
<div class="code-wrapper non-deduce"><code>union&nbsp;List&lt;T&gt;&nbsp;{<br>
&nbsp;&nbsp;empty<br>
&nbsp;&nbsp;node(T,&nbsp;List&lt;T&gt;)<br>
}</code></div>
<p>The sequence <code class="inline">3,8,4</code> can be represented as a <code class="inline">List</code> by creating three
nodes that are composed in the following way.</p>
<div class="code-wrapper"><code id="reference_list_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="mark">Mark</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"#"&nbsp;term&nbsp;"#"</code></div>
<p>Marking a subterm with hash symbols restricts a <code class="inline">replace</code> or <code class="inline">definition</code>
proof to only apply to that subterm.</p>
<p>The <a href="#equations" target="_self"><code class="inline">equations</code></a> feature, by default, places marks around the entire
left-hand side of each equation. However, you can override this
default by placing explicit marks.</p>
<div class="code-wrapper"><code id="reference_mark_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="modulo">Modulo</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"%"&nbsp;term</code></div>
<p>The modulo operator is defined in <code class="inline">Nat.pf</code> as follows.  The first
argument is a natural number (of type <code class="inline">Nat</code>) and the second argument
is a positive number (of type <code class="inline">Pos</code>).</p>
<div class="code-wrapper non-deduce"><code>n&nbsp;%&nbsp;m&nbsp;=&nbsp;n&nbsp;-&nbsp;(n&nbsp;/&nbsp;m)&nbsp;&ast;&nbsp;pos2nat(m)</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_mod_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="modus-ponens">Modus Ponens</h2>
<p>See the entry for <a href="#apply-to-proof-modus-ponens" target="_self">Apply-To</a>.</p>
<h2 id="multiply">Multiply</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"&ast;"&nbsp;term</code></div>
<p>Multiplication on natural numbers is defined in <code class="inline">Nat.pf</code> as follows.</p>
<div class="code-wrapper non-deduce"><code>function&nbsp;operator&nbsp;&ast;(Nat,Nat)&nbsp;-&gt;&nbsp;Nat&nbsp;{<br>
&nbsp;&nbsp;operator&nbsp;&ast;(0,&nbsp;m)&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;operator&nbsp;&ast;(suc(n),&nbsp;m)&nbsp;=&nbsp;m&nbsp;+&nbsp;(n&nbsp;&ast;&nbsp;m)<br>
}</code></div>
<p>To find theorems about multiplication, search for <code class="inline">mult</code> in <code class="inline">Nat.thm</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_multiply_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="multiset-type">MultiSet (Type)</h2>
<p>The <code class="inline">MultiSet&lt;T&gt;</code> type represents the standard mathematical notion of
a multiset, which is a set that may contain duplicates of an
element. The <code class="inline">MultiSet&lt;T&gt;</code> type is defined in <code class="inline">MultiSet.pf</code>.</p>
<h2 id="natural-number">Natural Number</h2>
<div class="code-wrapper non-deduce"><code>natural_number&nbsp;::=&nbsp;[0-9]+<br>
term&nbsp;::=&nbsp;natural_number</code></div>
<p>A natural number literal is a sequence of one or more digits.</p>
<h2 id="not">Not</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;"not"&nbsp;formula</code></div>
<p>The formula <code class="inline">not P</code> is true when <code class="inline">P</code> is false.
Deduce treats <code class="inline">not P</code> as syntactic sugar for <code class="inline">(if P then false)</code>.</p>
<h2 id="not-equal">Not Equal</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"&#x2260;"&nbsp;term<br>
formula&nbsp;::=&nbsp;term&nbsp;"/="&nbsp;term</code></div>
<p>Deduce treats <code class="inline">x ≠ y</code> as syntactic sugar for <code class="inline">not (x = y)</code>.</p>
<h2 id="obtain-proof">Obtain (Proof)</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"obtain"&nbsp;identifier_list&nbsp;"where"&nbsp;assumption&nbsp;"from"&nbsp;proof</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>obtain&nbsp;x1,...,xn&nbsp;where&nbsp;label:&nbsp;P&nbsp;from&nbsp;X<br>
Y</code></div>
<p>is a proof of formula <code class="inline">Q</code> if <code class="inline">Y</code> is a proof of <code class="inline">Q</code>.
The <code class="inline">X</code> must be a proof of the form <code class="inline">some x1:T1,...,xn:Tn. P</code>.
The proof <code class="inline">Y</code> may use the <code class="inline">label</code> as a proof of <code class="inline">P</code>
and it may also refer to the proof of <code class="inline">P</code> by writing <code class="inline">recall P</code>.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_obtain_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="or-logical-disjunction">Or  (logical disjunction)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;formula&nbsp;"or"&nbsp;formula</code></div>
<p>The formula <code class="inline">P or Q</code> is true when either <code class="inline">P</code> is true or <code class="inline">Q</code> is true.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_or_example"><!-- Generated by codeUtils.js --></code></div>
<p>To prove <code class="inline">P or Q</code> it is enough to just prove <code class="inline">P</code> or to just prove <code class="inline">Q</code>.</p>
<div class="code-wrapper"><code id="reference_or_example_intro1"><!-- Generated by codeUtils.js --></code></div>
<div class="code-wrapper"><code id="reference_or_example_intro2"><!-- Generated by codeUtils.js --></code></div>
<p>To use a given of the form <code class="inline">P or Q</code>, use
<a href="#cases-disjunction-elimination" target="_self">Cases (Disjunction Elimination)</a>.</p>
<h2 id="parentheses">Parentheses</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"("&nbsp;term&nbsp;")"<br>
formula&nbsp;::=&nbsp;"("&nbsp;formula&nbsp;")"<br>
proof&nbsp;::=&nbsp;"("&nbsp;proof&nbsp;")"</code></div>
<p>A term, formula, or a proof may be surrounded in parentheses.</p>
<h2 id="pattern">Pattern</h2>
<div class="code-wrapper non-deduce"><code>pattern&nbsp;::=&nbsp;identifier&nbsp;|&nbsp;"0"&nbsp;|&nbsp;"true"&nbsp;|&nbsp;"false"&nbsp;|&nbsp;identifier&nbsp;"("&nbsp;identifier_list&nbsp;")"</code></div>
<p>This syntax is used in <a href="#switch-term" target="_self">Switch (Term)</a>, <a href="#switch-proof" target="_self">Switch (Proof)</a>,
and <a href="#function-statement" target="_self">Function (Statement)</a> via a Pattern List.</p>
<h2 id="parameter-list">Parameter List</h2>
<div class="code-wrapper non-deduce"><code>param_list&nbsp;::=&nbsp;ε&nbsp;|&nbsp;pattern&nbsp;|&nbsp;pattern&nbsp;","&nbsp;identifier_list</code></div>
<p>A parameter list begins with a pattern (for the first function
parameter) and then continues with a comma-separated sequence of zero
or more identifiers (for the rest of the function parameters).</p>
<h2 id="period-proof-of-true">Period (Proof of True)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"."</code></div>
<p>A period is a proof of the formula <code class="inline">true</code> in Deduce.</p>
<h2 id="pos-positive-integers">Pos (Positive Integers)</h2>
<p>The type of positive integers <code class="inline">Pos</code> is defined in <code class="inline">Nat.pf</code>.</p>
<h2 id="proof">Proof</h2>
<div class="code-wrapper non-deduce"><code>proof&nbsp;::=&nbsp;proof_stmt&nbsp;proof<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;conclusion</code></div>
<p>A proof is a sequence of zero or more <a href="#proof-statement" target="_self">proof statements</a>
that finishes with a <a href="#conclusion-proof" target="_self">conclusion</a>.</p>
<h2 id="proof-list">Proof List</h2>
<div class="code-wrapper non-deduce"><code>proof_list&nbsp;::&nbsp;proof&nbsp;<br>
proof_list&nbsp;::=&nbsp;proof&nbsp;"|"&nbsp;proof_list</code></div>
<p>A list of proofs separated by vertical bars. This syntax is used
in <a href="#rewrite-proof" target="_self">Rewrite (Proof)</a>.</p>
<h2 id="proof-statement">Proof Statement</h2>
<p>The following are proof statements (<code class="inline">proof_stmt</code> symbol in the grammar).
A proof may begin with zero or more proof statements, but it must end
with a <a href="#conclusion-proof" target="_self">Conclusion</a> (not a proof statement).</p>
<ul>
<li><a href="#arbitrary-forall-introduction" target="_self">Arbitrary</a></li>
<li><a href="#assume" target="_self">Assume</a></li>
<li><a href="#choose-proof" target="_self">Choose</a></li>
<li><a href="#define-proof" target="_self">Define</a></li>
<li><a href="#extensionality" target="_self">Extensionality</a></li>
<li><a href="#have-proof-statement" target="_self">Have</a></li>
<li><a href="#injective-proof" target="_self">Injective</a></li>
<li><a href="#obtain-exists-elimination" target="_self">Obtain</a></li>
<li><a href="#suffices-proof-statement" target="_self">Suffices</a></li>
<li><a href="#suppose" target="_self">Suppose</a></li>
</ul>
<h2 id="print-statement">Print (Statement)</h2>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"print"&nbsp;term</code></div>
<p>You can ask Deduce to print a value to standard output using the
<code class="inline">print</code> statement.</p>
<div class="code-wrapper"><code id="reference_print_example"><!-- Generated by codeUtils.js --></code></div>
<p>The output is <code class="inline">5</code>.</p>
<h2 id="question-mark-proof">Question Mark <code class="inline">?</code> (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"?"</code></div>
<p>A proof can be left incomplete by placing a <code class="inline">?</code> in the part that you
don't know. Deduce halts at the <code class="inline">?</code> and prints an error message with
the location of the <code class="inline">?</code> and the formula that needs to be proved, as
well as some advice about how to prove it.</p>
<h2 id="recall-proof">Recall (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"recall"&nbsp;term_list</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>recall&nbsp;P1,&nbsp;...,&nbsp;Pn</code></div>
<p>is a proof of the formula <code class="inline">P1 and ... and Pn</code>. The formulas
<code class="inline">P1</code>,...,<code class="inline">Pn</code> must be in the givens at the current point in the proof.</p>
<h2 id="recursive-function-statement">Recursive Function (Statement)</h2>
<p>(The <code class="inline">recursive</code> keyword was added in Deduce version 1.1
as a replacement for <code class="inline">function</code>.)</p>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"recursive"&nbsp;identifier&nbsp;type_params_opt&nbsp;"("&nbsp;type_list&nbsp;")"&nbsp;"-&gt;"&nbsp;type&nbsp;"{"&nbsp;fun_case&ast;&nbsp;"}"<br>
fun_case&nbsp;::=&nbsp;identifier&nbsp;"("&nbsp;pattern_list&nbsp;")"&nbsp;"="&nbsp;term</code></div>
<p>The <code class="inline">recursive</code> statement is for defining recursive functions that
operate on <code class="inline">union</code> types. Recursive functions in Deduce are somewhat
special to make sure they always terminate.</p>
<ul>
<li>The first parameter of the function must be a union.</li>
<li>The function definition must include a clause for every</li>
</ul>
<p>constructor in the union.</p>
<ul>
<li>The first argument of every recursive call must be a sub-part of the</li>
</ul>
<p>current constructor of the union.</p>
<p>A recursive function begins with the <code class="inline">recursive</code> keyword (or <code class="inline">function</code> in version 1.0),
followed by the name of the function, then the parameters types and the return
type. The body of the function includes one equation for every
constructor in the union of its first parameter. For example, here's
the definition of a <code class="inline">length</code> function for lists of natural numbers.</p>
<div class="code-wrapper"><code id="reference_function_length_example"><!-- Generated by codeUtils.js --></code></div>
<p>There are two clauses in the body of <code class="inline">length</code> because the <code class="inline">NatList</code> union
has two constructors. The clause for <code class="inline">Empty</code> says that its length is
<code class="inline">0</code>.  The clause for <code class="inline">Node</code> says that its length is one more than the
length of the rest of the linked list.  Deduce approves of the
recursive call <code class="inline">length(next)</code> because <code class="inline">next</code> is part of <code class="inline">Node(n, next)</code>.</p>
<p>Recursive functions may have more than one parameter but pattern
matching is only supported for the first parameter. 
If you need to pattern match on a parameter that is not the first, you
can use a <code class="inline">switch</code> statement. </p>
<h2 id="reflexive-proof">Reflexive (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;reflexive</code></div>
<p>The proof <code class="inline">reflexive</code> proves that <code class="inline">a = a</code> for any term <code class="inline">a</code>.</p>
<h2 id="replace-proof">Replace (Proof)</h2>
<p>(This feature was added in Deduce version 1.1.)</p>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"replace"&nbsp;proof_list</code></div>
<p>An alternative syntax for <a href="#rewrite-proof" target="_self">Rewrite</a>.</p>
<h2 id="rewrite-proof">Rewrite (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"rewrite"&nbsp;proof_list</code></div>
<p>Rewrite the current goal formula according to the equalities proved by
the specified <a href="#proof-list" target="_self">Proof List</a>. Each equality may be a
literal equality (has the form <code class="inline">LHS = RHS</code>) or it can be a generalized
equality (has the form <code class="inline">all x1:T1,...,xn:Tn. LHS = RHS</code>).</p>
<p>For each equality going left-to-right in the proof list, any subterm
in the goal formula that matches the left-hand side of the equality
(<code class="inline">LHS</code>) is replaced by the right-hand side of the equality
(<code class="inline">RHS</code>). Once a subterm is rewritten by an equality, the resulting
subterm is not rewritten further by the same equality. On the other
hand, rewriting with an equality may apply to multiple disjoint
locations in a formula.</p>
<p>If the rewriting done by all of the equalities simplifies the goal
formula to <code class="inline">true</code>, then this statement proves the goal.  Otherwise,
Deduce signals an error.</p>
<div class="code-wrapper"><code id="reference_rewrite_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="replace-in-proof">Replace-In (Proof)</h2>
<p>(This feature was added in Deduce version 1.1.)</p>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"replace"&nbsp;proof_list&nbsp;"in"&nbsp;proof</code></div>
<p>An alternative syntax for <a href="#rewrite-in-proof" target="_self">Rewrite-In</a>.</p>
<h2 id="rewrite-in-proof">Rewrite-In (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"rewrite"&nbsp;proof_list&nbsp;"in"&nbsp;proof</code></div>
<p>In the formula of the given proof, rewrite according to the equalities
proved by the specified <a href="#proof-list" target="_self">Proof List</a>, resulting in the
formula that is proved by this <code class="inline">rewrite</code>-<code class="inline">in</code> statement. 
The algorithm for rewriting described in the entry for
<a href="#rewrite-proof" target="_self">Rewrite (Proof)</a>.</p>
<div class="code-wrapper"><code id="reference_rewrite_in_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="set-type">Set (Type)</h2>
<p>The <code class="inline">Set&lt;T&gt;</code> type defined in <code class="inline">Set.pf</code> represents the standard
mathematical notion of a set. The empty set is written <code class="inline">∅</code> and the
usual set operations such as union <code class="inline">∪</code>, intersection <code class="inline">∩</code>, membership
<code class="inline">∈</code>, and subset-or-equal <code class="inline">⊆</code> are all defined in <code class="inline">Set.pf</code>.  The
<code class="inline">Set.thm</code> file provides a summary of the many theorems about sets that
are proved in <code class="inline">Set.pf</code>.</p>
<h2 id="some-formula">Some (Formula)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;"some"&nbsp;var_list&nbsp;"."&nbsp;formula</code></div>
<p>The formula <code class="inline">some x1:T1,...,xn:Tn. P</code> is true when there exists
a choice for <code class="inline">x1</code>,...,<code class="inline">xn</code> such that <code class="inline">P</code> is true.</p>
<p>To prove a <code class="inline">some</code> formula, see the entry for
<a href="#choose-proof" target="_self">Choose</a>.</p>
<p>To use a <code class="inline">some</code> formula, see the entry for <a href="#obtain-exists-elimination" target="_self">Obtain</a></p>
<h2 id="sorry-proof">Sorry (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"sorry"</code></div>
<p><code class="inline">sorry</code> is the get-out-of-jail free card. It can prove anything.
However, it prints a warning message with the location of the <code class="inline">sorry</code>.</p>
<h2 id="subset-or-equal">Subset or Equal</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;term&nbsp;"&#x2286;"&nbsp;term<br>
formula&nbsp;::=&nbsp;term&nbsp;"(="&nbsp;term</code></div>
<p>The formula <code class="inline">A ⊆ B</code> is true when every element of set <code class="inline">A</code> is
contained in set <code class="inline">B</code>. That is, given <code class="inline">A</code> and <code class="inline">B</code> of type <code class="inline">Set&lt;T&gt;</code>,
the definition of <code class="inline">A ⊆ B</code> is as follows.</p>
<div class="code-wrapper non-deduce"><code>A&nbsp;&#x2286;&nbsp;B&nbsp;=&nbsp;(all&nbsp;x:T.&nbsp;if&nbsp;x&nbsp;&#x2208;&nbsp;A&nbsp;then&nbsp;x&nbsp;&#x2208;&nbsp;B)</code></div>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_subset_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="subtract">Subtract</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"-"&nbsp;term</code></div>
<p>Subtraction for natural numbers is defined in <code class="inline">Nat.pf</code> as follows</p>
<div class="code-wrapper non-deduce"><code>function&nbsp;operator&nbsp;-(Nat,Nat)&nbsp;-&gt;&nbsp;Nat&nbsp;{<br>
&nbsp;&nbsp;operator&nbsp;-(0,&nbsp;m)&nbsp;=&nbsp;0<br>
&nbsp;&nbsp;operator&nbsp;-(suc(n),&nbsp;m)&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;m&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;0&nbsp;{&nbsp;suc(n)&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;suc(m')&nbsp;{&nbsp;n&nbsp;-&nbsp;m'&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}</code></div>
<p>Note that subtraction on natural numbers is different from subtraction
on integers, as they are no negative natural numbers. If you subtract
a larger natural number from a smaller natural number, the result is <code class="inline">0</code>.</p>
<div class="code-wrapper non-deduce"><code>assert&nbsp;3&nbsp;-&nbsp;2&nbsp;=&nbsp;1<br>
assert&nbsp;3&nbsp;-&nbsp;3&nbsp;=&nbsp;0<br>
assert&nbsp;2&nbsp;-&nbsp;3&nbsp;=&nbsp;0</code></div>
<p>To search for theorems about subtraction in <code class="inline">Nat.thy</code>, search for
theorems with <code class="inline">sub</code> in the name.</p>
<h2 id="suffices-proof-statement">Suffices (Proof Statement)</h2>
<div class="code-wrapper non-deduce"><code>proof_stmt&nbsp;::=&nbsp;"suffices"&nbsp;formula&nbsp;"by"&nbsp;proof</code></div>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>suffices&nbsp;P&nbsp;by&nbsp;X<br>
Y</code></div>
<p>is a proof of the formula <code class="inline">Q</code> if <code class="inline">X</code> is a proof that <code class="inline">P</code> implies <code class="inline">Q</code>
and <code class="inline">Y</code> is a proof of <code class="inline">Q</code>.</p>
<p>Use <code class="inline">suffices</code> to transform the goal formula into a simpler formula.
Thus, the <code class="inline">suffices</code> feature enables reasoning backwards from the goal.</p>
<p>Example:</p>
<p>One often wants to transform the goal by using a definition or equation.
For example, in the following theorem we change the goal
from</p>
<div class="code-wrapper non-deduce"><code>length(node(3,&nbsp;empty))&nbsp;=&nbsp;1</code></div>
<p>into</p>
<div class="code-wrapper non-deduce"><code>1&nbsp;+&nbsp;0&nbsp;=&nbsp;1</code></div>
<p>by two uses of the definition of <code class="inline">length</code>.
We then prove the new goal with theorem <code class="inline">add_zero</code> from <code class="inline">Nat.thm</code>.</p>
<div class="code-wrapper"><code id="reference_suffices_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="suffices-omitted-term">Suffices Omitted Term</h2>
<p>Use suffices without explicitly stating the new goal. 
Instead, you can use <code class="inline">─</code> or <code class="inline">__</code> to fill in what the new goal should be. </p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_suffices_omitted_example"><!-- Generated by codeUtils.js --></code></div>
<p>This acts similarly to <a href="#question-mark--proof" target="_self"><code class="inline">?</code></a>, except that deduce will fill in the omitted term internally and accept the proof as complete.</p>
<h2 id="suppose">Suppose</h2>
<p>See the entry for <a href="#assume" target="_self">Assume</a>.</p>
<h2 id="switch-term">Switch (Term)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;"switch"&nbsp;term&nbsp;"{"&nbsp;switch_case&ast;&nbsp;"}"<br>
switch_case&nbsp;::=&nbsp;"case"&nbsp;pattern&nbsp;"{"&nbsp;term&nbsp;"}"</code></div>
<p>(See the entry for <a href="#pattern" target="_self">Pattern</a> for the syntax of <code class="inline">pattern</code>.)</p>
<p>The subject of the <code class="inline">switch</code> must be of union type or <code class="inline">bool</code> (e.g., not
a function). The body of the <code class="inline">switch</code> must have one <code class="inline">case</code> for every
constructor in the <code class="inline">union</code>, or for <code class="inline">bool</code>, the cases are <code class="inline">true</code> and
<code class="inline">false</code>.  The body of each <code class="inline">case</code> is a term and they all must have the
same type.  The <code class="inline">switch</code> evaluates the subject and compares it to each
case, then evaluates the body of the case that matched.</p>
<div class="code-wrapper"><code id="reference_switch_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="switch-proof">Switch (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"switch"&nbsp;term&nbsp;"{"&nbsp;switch_proof_case&ast;&nbsp;"}"<br>
switch_proof_case&nbsp;::=&nbsp;"case"&nbsp;pattern&nbsp;"{"&nbsp;proof&nbsp;"}"<br>
switch_proof_case&nbsp;::=&nbsp;"case"&nbsp;pattern&nbsp;assumptions&nbsp;"{"&nbsp;proof&nbsp;"}"<br>
assumptions&nbsp;::=&nbsp;"suppose"&nbsp;assumption_list&nbsp;|&nbsp;"assume"&nbsp;assumption_list</code></div>
<p>(See entry for Assumption List for the syntax of <code class="inline">assumption_list</code>.)</p>
<p>A proof of the form</p>
<div class="code-wrapper non-deduce"><code>switch&nbsp;t&nbsp;{<br>
&nbsp;&nbsp;case&nbsp;p1&nbsp;assume&nbsp;eq1:&nbsp;t&nbsp;=&nbsp;p1&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;X1<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;...<br>
&nbsp;&nbsp;case&nbsp;pn&nbsp;assume&nbsp;eqn:&nbsp;t&nbsp;=&nbsp;pn&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Xn<br>
&nbsp;&nbsp;}<br>
}</code></div>
<p>is a proof of formula <code class="inline">R</code> if <code class="inline">X1</code>,...,<code class="inline">Xn</code> are all proofs of <code class="inline">R</code>.
The fact <code class="inline">t = p1</code> is a given that can be used in <code class="inline">X1</code>
and similarly for the other cases.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_switch_proof_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="symmetric-proof">Symmetric (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"symmetric"&nbsp;proof</code></div>
<p>If <code class="inline">X</code> is a proof of <code class="inline">a = b</code>, then <code class="inline">symmetric X</code> is a proof of <code class="inline">b = a</code>
for any terms <code class="inline">a</code> and <code class="inline">b</code>.</p>
<h2 id="theorem-statement">Theorem (Statement)</h2>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"theorem"&nbsp;IDENT&nbsp;":"&nbsp;term&nbsp;"proof"&nbsp;proof&nbsp;"end"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;"lemma"&nbsp;IDENT&nbsp;":"&nbsp;term&nbsp;"proof"&nbsp;proof&nbsp;"end"</code></div>
<p>A theorem (or lemma) proves that a formula is true. The theorem's name
can then be used later when one needs to prove the formula again.</p>
<p>A theorem has the form</p>
<div class="code-wrapper non-deduce"><code>theorem&nbsp;label:&nbsp;P<br>
proof<br>
&nbsp;&nbsp;X<br>
end</code></div>
<p>The proof <code class="inline">X</code> must prove the formula <code class="inline">P</code>. After the theorem, the <code class="inline">label</code> can be used
as a proof of <code class="inline">P</code>.</p>
<h2 id="term-list">Term List</h2>
<p>A term list is a comma-separated sequence of zero or more terms.</p>
<div class="code-wrapper non-deduce"><code>term_list&nbsp;::=&nbsp;ε&nbsp;|&nbsp;term&nbsp;|&nbsp;term&nbsp;","&nbsp;term_list</code></div>
<h2 id="transitive-proof">Transitive (Proof)</h2>
<div class="code-wrapper non-deduce"><code>conclusion&nbsp;::=&nbsp;"transitive"&nbsp;proof&nbsp;proof</code></div>
<p>If <code class="inline">X</code> is a proof of <code class="inline">a = b</code> and <code class="inline">Y</code> is a proof of <code class="inline">b = c</code>,
then <code class="inline">transitive X Y</code> is a proof of <code class="inline">a = c</code>, for any
terms <code class="inline">a</code>, <code class="inline">b</code>, and <code class="inline">c</code>.</p>
<h2 id="true-formula">True (Formula)</h2>
<div class="code-wrapper non-deduce"><code>formula&nbsp;::=&nbsp;"true"</code></div>
<p>There's not much to say about <code class="inline">true</code>. It's true!
Proving <code class="inline">true</code> is easy. Just use a period.</p>
<div class="code-wrapper"><code id="reference_true_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="type">Type</h2>
<div class="code-wrapper non-deduce"><code>type&nbsp;::=&nbsp;"bool"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;type&nbsp;of&nbsp;a&nbsp;Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;identifier&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;type&nbsp;of&nbsp;a&nbsp;union<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;identifier&nbsp;"&lt;"&nbsp;type_list&nbsp;"&gt;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;type&nbsp;of&nbsp;a&nbsp;generic&nbsp;union<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"fn"&nbsp;type_params_opt&nbsp;type_list&nbsp;"-&gt;"&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;type&nbsp;of&nbsp;a&nbsp;function&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"("&nbsp;type&nbsp;")"</code></div>
<h2 id="type-list">Type List</h2>
<div class="code-wrapper non-deduce"><code>type_list&nbsp;::=&nbsp;ε&nbsp;|&nbsp;type&nbsp;|&nbsp;type&nbsp;","&nbsp;type_list</code></div>
<p>A type list is a comma-separated list of zero or more types.</p>
<h2 id="type-parameters">Type Parameters</h2>
<div class="code-wrapper non-deduce"><code>type_params_opt&nbsp;::=&nbsp;ε&nbsp;|&nbsp;"&lt;"&nbsp;identifier_list&nbsp;"&gt;"</code></div>
<p>Specifies the type parameters of a generic union or generic function.</p>
<h2 id="union-statement">Union (Statement)</h2>
<div class="code-wrapper non-deduce"><code>statement&nbsp;::=&nbsp;"union"&nbsp;identifier&nbsp;type_params_opt&nbsp;"{"&nbsp;constructor&ast;&nbsp;"}"<br>
constructor&nbsp;::=&nbsp;identifier&nbsp;|&nbsp;identifier&nbsp;"("&nbsp;type_list&nbsp;")"</code></div>
<p>The <code class="inline">union</code> statement defines a new type whose values are created by
invoking one of the constructors declared inside the union.</p>
<p>Example:</p>
<p>The following union statement defines a <code class="inline">Tree</code> type that has two kinds
of nodes, <code class="inline">Leaf</code> nodes with zero children and <code class="inline">Internal</code> nodes with
two children. We create a three-node tree <code class="inline">T3</code> by using the
constructors <code class="inline">Leaf</code> and <code class="inline">Internal</code> to create the nodes.</p>
<div class="code-wrapper"><code id="reference_union_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="union-operator-on-sets">Union (Operator on Sets)</h2>
<div class="code-wrapper non-deduce"><code>term&nbsp;::=&nbsp;term&nbsp;"&#x222A;"&nbsp;term<br>
term&nbsp;::=&nbsp;term&nbsp;"|"&nbsp;term</code></div>
<p>Set union is defined in <code class="inline">Set.pf</code>.
The union of sets <code class="inline">A</code> and <code class="inline">B</code>, written <code class="inline">A ∪ B</code>,
contains the items that occur in either set.</p>
<p>Example:</p>
<div class="code-wrapper"><code id="reference_set_union_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="variable-list">Variable List</h2>
<div class="code-wrapper non-deduce"><code>var_list&nbsp;::=&nbsp;ε&nbsp;|&nbsp;ident&nbsp;|&nbsp;ident&nbsp;":"&nbsp;type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;ident&nbsp;":"&nbsp;type&nbsp;","&nbsp;var_list<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;ident&nbsp;","&nbsp;var_list</code></div>
<p>A comma-separated list of variable declarations. Each variable may
optionally be annotated with its type.</p>
<!--

!!!{.deduce^file=Reference.pf} 
import Nat
import List
import Set
import MultiSet
import Maps
import Pair

&lt;&lt;function_length_example&gt;&gt;
&lt;&lt;add_example&gt;&gt;
&lt;&lt;add_multiset_example&gt;&gt;
&lt;&lt;all_example_bool&gt;&gt;
&lt;&lt;all_example_intro&gt;&gt;
&lt;&lt;all_example_elim&gt;&gt;
&lt;&lt;and_example&gt;&gt;
&lt;&lt;and_example_intro&gt;&gt;
&lt;&lt;and_example_elim&gt;&gt;
&lt;&lt;append_example&gt;&gt;
&lt;&lt;apply_to_example&gt;&gt;
&lt;&lt;arbitrary_example&gt;&gt;
&lt;&lt;assert_example&gt;&gt;
&lt;&lt;assume_example&gt;&gt;
&lt;&lt;list_example&gt;&gt;
&lt;&lt;call_example&gt;&gt;
&lt;&lt;choose_example&gt;&gt;
&lt;&lt;compose_example&gt;&gt;
&lt;&lt;conclude_example&gt;&gt;
&lt;&lt;conjunct_example&gt;&gt;
&lt;&lt;define_example&gt;&gt;
&lt;&lt;define_term_example&gt;&gt;
&lt;&lt;define_proof_example&gt;&gt;
&lt;&lt;definition_example&gt;&gt;
&lt;&lt;definition_in_example&gt;&gt;
&lt;&lt;division_example&gt;&gt;
&lt;&lt;equations_example&gt;&gt;
&lt;&lt;equations_def_example&gt;&gt;
&lt;&lt;greater_example&gt;&gt;
&lt;&lt;greater_equal_example&gt;&gt;
&lt;&lt;if_then_else_example&gt;&gt;
&lt;&lt;membership_example&gt;&gt;
&lt;&lt;induction_example&gt;&gt;
&lt;&lt;instantiate_example&gt;&gt;
&lt;&lt;intersect_example&gt;&gt;
&lt;&lt;less_than_example&gt;&gt;
&lt;&lt;less_equal_example&gt;&gt;
&lt;&lt;mark_example&gt;&gt;
&lt;&lt;mod_example&gt;&gt;
&lt;&lt;obtain_example&gt;&gt;
&lt;&lt;or_example&gt;&gt;
&lt;&lt;or_example_intro1&gt;&gt;
&lt;&lt;or_example_intro2&gt;&gt;
&lt;&lt;print_example&gt;&gt;
&lt;&lt;rewrite_example&gt;&gt;
&lt;&lt;rewrite_in_example&gt;&gt;
&lt;&lt;switch_example&gt;&gt;
&lt;&lt;switch_proof_example&gt;&gt;
&lt;&lt;subset_example&gt;&gt;
&lt;&lt;suffices_example&gt;&gt;
&lt;&lt;true_example&gt;&gt;
&lt;&lt;union_example&gt;&gt;
&lt;&lt;fun_exchange_example&gt;&gt;
&lt;&lt;generic_fun_example&gt;&gt;
!!!


-->
        <deduce-footer>
            <!-- custom component defined in script.js -->
        </deduce-footer>
    </div>


    <script src="../js/cache.js"></script>
    <script src="../js/script.js"></script>
    <script src="../js/code.js"></script>
    <script src="../js/codeUtils.js"></script>
</body>

</html>
    