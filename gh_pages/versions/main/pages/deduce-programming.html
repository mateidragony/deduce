
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="A guide on deduce programming with exercises.">
    <meta name="keywords" content="Deduce, Proof, Programming">
    <meta name="author" content="Jeremy Siek">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deduce | Programming</title>

    <!-- Social cards -->
    <meta property="og:url" content="https://jsiek.github.io/deduce/pages/deduce-programming.html" />
    <meta property="og:type" content="website"/>
    <meta property="og:title" content="Deduce | Programming" />
    <meta property="og:description" content="A guide on deduce programming with exercises." />
    <meta property="og:site_name" content="Deduce">
    <meta property="og:image" content="https://jsiek.github.io/deduce/images/logo.svg" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Deduce | Programming">
    <meta name="twitter:description" content="A guide on deduce programming with exercises.">
    <meta name="twitter:image" content="https://jsiek.github.io/deduce/images/logo.svg">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../images/logo.svg">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Josefin+Slab:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">

    <!-- Font awesome -->
    <script src="https://kit.fontawesome.com/7005573326.js" crossorigin="anonymous"></script>

    <!-- My stylesheets -->
    <link rel="stylesheet" href="../css/normalize.css">
    <link id="stylesheet" rel="stylesheet" href="../css/style.css">
</head>

<body>

    <div class="container md deduce-programming">
        <deduce-nav>
            <!-- custom component defined in script.js -->
        </deduce-nav>
    <h1 id="programming-in-deduce">Programming in Deduce</h1>
<p>Deduce supports the following language features:</p>
<ul>
<li><a href="#import" target="_self">Import</a></li>
<li><a href="#definitions" target="_self">Definitions</a></li>
<li><a href="#printing-values" target="_self">Printing Values</a></li>
<li><a href="#function-statement" target="_self">Functions</a></li>
<li><a href="#unions-and-switch" target="_self">Unions and Switch</a></li>
<li><a href="#natural-numbers" target="_self">Natural Numbers</a></li>
<li><a href="#lists" target="_self">Lists</a></li>
<li><a href="#booleans-conditionals-and-assert" target="_self">Booleans, Conditionals, and Assert</a></li>
<li><a href="#recursive-functions" target="_self">Recursive Functions</a></li>
<li><a href="#generic-functions" target="_self">Generic Functions</a></li>
<li><a href="#higher-order-functions" target="_self">Higher-order Functions</a></li>
<li><a href="#pairs" target="_self">Pairs</a></li>
</ul>
<p>The following subsections describe each of these features.
There are several <a href="#exercises" target="_self">exercises</a> at the end 
that you can use to check your understanding.</p>
<h2 id="import">Import</h2>
<p>The <code class="inline">import</code> declaration makes available the contents of another
Deduce file in the current file. For example, you can import the
contents of <code class="inline">Nat.pf</code> as follows</p>
<div class="code-wrapper"><code id="programming_ImportNat"><!-- Generated by codeUtils.js --></code></div>
<h2 id="definitions">Definitions</h2>
<p>The <code class="inline">define</code> feature of Deduce associates a name with a value.
The following definitions associate the name <code class="inline">five</code> with the
natural number <code class="inline">5</code>, and the name <code class="inline">six</code> with the natural
number <code class="inline">6</code>.</p>
<div class="code-wrapper"><code id="programming_five_six"><!-- Generated by codeUtils.js --></code></div>
<p>Optionally, the type can be specified after the name, following a
colon.  In the above, <code class="inline">six</code> holds a natural number, so its type is
<code class="inline">Nat</code>.</p>
<h2 id="printing-values">Printing Values</h2>
<p>You can ask Deduce to print a value to standard output using the
<code class="inline">print</code> statement.</p>
<div class="code-wrapper"><code id="programming_print_five"><!-- Generated by codeUtils.js --></code></div>
<p>The output is <code class="inline">5</code>.</p>
<h2 id="function-statement">Function (Statement)</h2>
<p>A function statement starts <code class="inline">fun</code>, followed by parameter names
and their types, then the body of the function enclosed in braces.
For example, the following creates a function for computing the area
of a rectangle.</p>
<div class="code-wrapper"><code id="programming_area"><!-- Generated by codeUtils.js --></code></div>
<p>To call a function, apply it to the appropriate number and type of
arguments.</p>
<div class="code-wrapper"><code id="programming_print_area"><!-- Generated by codeUtils.js --></code></div>
<p>The output is <code class="inline">12</code>.</p>
<h2 id="unions-and-switch">Unions and Switch</h2>
<p>The <code class="inline">union</code> feature of Deduce defines a type whose values are created
by one or more constructors.  A union definition specifies a name for
the union type and its body specifies the name of each constructor and
its parameter types. For example, we define the following union to
represent a linked-list of natural numbers.</p>
<div class="code-wrapper"><code id="programming_NatList"><!-- Generated by codeUtils.js --></code></div>
<p>We can then construct values of type <code class="inline">NatList</code> using the constructors
<code class="inline">Empty</code> and <code class="inline">Node</code>.  To create a linked-list whose elements are
<code class="inline">1</code> and <code class="inline">2</code>, write:</p>
<div class="code-wrapper"><code id="programming_NL12"><!-- Generated by codeUtils.js --></code></div>
<p>Unions may be recursive: a constructor may include a parameter type
that is the union type, e.g., the <code class="inline">NatList</code> parameter of <code class="inline">Node</code>. </p>
<h2 id="generic-unions">Generic Unions</h2>
<p>Unions may be generic: one can parameterize a union
with one or more type parameters. For example, we generalize linked
lists to any element types as follows.</p>
<div class="code-wrapper"><code id="programming_List"><!-- Generated by codeUtils.js --></code></div>
<p>Constructing values of a generic union looks the same as for a regular
union. Deduce figures out the type for <code class="inline">T</code> from the types of
the constructor arguments.</p>
<div class="code-wrapper"><code id="programming_L12"><!-- Generated by codeUtils.js --></code></div>
<h2 id="lists">Lists</h2>
<p>The file <code class="inline">List.pf</code> includes the union type we defined
<a href="#generic-unions" target="_self">above</a> as well as operations on lists and theorems
about them. Deduce provides shorthand notation for lists where:</p>
<ul>
<li><code class="inline">[]</code> is shorthand for <code class="inline">empty</code></li>
<li><code class="inline">[1]</code> is shorthand for <code class="inline">node(1, empty)</code></li>
<li><code class="inline">[1, 2]</code> is shorthand for <code class="inline">node(1, node(2, empty))</code></li>
<li>etc.</li>
</ul>
<h2 id="switch">Switch</h2>
<p>You can branch on a value of union type using <code class="inline">switch</code>. For example,
the following <code class="inline">front</code> function returns the first element of a <code class="inline">NatList</code>. Here
we give an explicit type annotation for the <code class="inline">front</code> function. The type
of a function starts with <code class="inline">fn</code>, followed by the parameter types, then
<code class="inline">-&gt;</code>, and finally the return type.</p>
<div class="code-wrapper"><code id="programming_front"><!-- Generated by codeUtils.js --></code></div>
<p>The output of </p>
<div class="code-wrapper"><code id="programming_print_front"><!-- Generated by codeUtils.js --></code></div>
<p>is <code class="inline">just(1)</code>.</p>
<p>The <code class="inline">switch</code> compares the discriminated value with the
constructor pattern of each <code class="inline">case</code> and when it finds a match,
it initializes the pattern variables from the parts of the
discriminated value and then evaluates the branch associated with the
<code class="inline">case</code>.</p>
<p>If you forget a <code class="inline">case</code> in a <code class="inline">switch</code>, Deduce will tell
you. For example, if you try the following:</p>
<div class="code-wrapper"><code id="programming_broken_front"><!-- Generated by codeUtils.js --></code></div>
<p>Deduce responds with</p>
<div class="code-wrapper non-deduce"><code>this&nbsp;switch&nbsp;is&nbsp;missing&nbsp;a&nbsp;case&nbsp;for:&nbsp;Node(Nat,NatList)</code></div>
<h2 id="natural-numbers">Natural Numbers</h2>
<p>Natural numbers are not a builtin type in Deduce but instead they
are defined as a <code class="inline">union</code> type:</p>
<div class="code-wrapper"><code id="programming_Nat"><!-- Generated by codeUtils.js --></code></div>
<p>The file <code class="inline">Nat.pf</code> includes the above definition together with some
operations on natural numbers and theorems about them.  The numerals
<code class="inline">0</code>, <code class="inline">1</code>, <code class="inline">2</code>, etc. are shorthand for the natural numbers <code class="inline">zero</code>,
<code class="inline">suc(zero)</code>, <code class="inline">suc(suc(zero))</code>, etc.</p>
<h2 id="booleans-conditionals-and-assert">Booleans, Conditionals, and Assert</h2>
<p>Deduce includes the values <code class="inline">true</code> and <code class="inline">false</code> of type
<code class="inline">bool</code> and the usual boolean operations such as <code class="inline">and</code>,
<code class="inline">or</code>, and <code class="inline">not</code>.  Deduce also provides an if-then-else
term that branches on the value of a boolean. For example, the
following if-then-else term is evaluates to <code class="inline">7</code>.</p>
<div class="code-wrapper"><code id="programming_print7"><!-- Generated by codeUtils.js --></code></div>
<p>The <code class="inline">assert</code> statement evaluates a term and reports an
error if the result is <code class="inline">false</code>. For example, the following
<code class="inline">assert</code> does nothing because the term evaluates to
<code class="inline">true</code>.</p>
<div class="code-wrapper"><code id="programming_assert_if_true"><!-- Generated by codeUtils.js --></code></div>
<h2 id="recursive-functions">Recursive Functions</h2>
<p>Recursive functions in Deduce are somewhat special to make sure they
always terminate.</p>
<ul>
<li>The first parameter of the function must be a union.</li>
<li>The function definition must include a clause for every</li>
</ul>
<p>constructor in the union.</p>
<ul>
<li>The first argument of every recursive call must be a sub-part of the</li>
</ul>
<p>current constructor of the union.</p>
<p>A recursive function begins with the <code class="inline">recursive</code> keyword, followed by
the name of the function, then the parameters types and the return
type. For example, here's the definition of a <code class="inline">len</code> function for
lists of natural numbers.</p>
<div class="code-wrapper"><code id="programming_lenNatList"><!-- Generated by codeUtils.js --></code></div>
<p>There are two clauses in the body. The clause for <code class="inline">Empty</code> says
that its length is <code class="inline">0</code>.  The clause for <code class="inline">Node</code> says that
its length is one more than the length of the rest of the linked list.
Deduce approves of the recursive call <code class="inline">len(next)</code> because
<code class="inline">next</code> is part of <code class="inline">Node(n, next)</code>.</p>
<p>Recursive functions may have more than one parameter but pattern
matching is only supported for the first parameter. For example, here
is the <code class="inline">app</code> function that combines two linked lists.</p>
<div class="code-wrapper"><code id="programming_app"><!-- Generated by codeUtils.js --></code></div>
<p>If you need to pattern match on a parameter that is not the first, you
can use a <code class="inline">switch</code> statement. For example, the following <code class="inline">zip</code>
function (defined in <code class="inline">List.pf</code>) combines two lists into a single list
of pairs. The function is defined by two clauses that pattern match on
the first parameter. However, <code class="inline">zip</code> also needs to match on the second
parameter <code class="inline">ys</code>, which is accomplished with a <code class="inline">switch</code> statement.</p>
<div class="code-wrapper"><code id="programming_zip_example"><!-- Generated by codeUtils.js --></code></div>
<h2 id="generic-functions">Generic Functions</h2>
<p>Deduce supports generic functions, so we can generalize <code class="inline">length</code> to
work on lists with any element type as follows.</p>
<div class="code-wrapper"><code id="programming_length"><!-- Generated by codeUtils.js --></code></div>
<p>Generic functions that are not recursive can be defined using a
combination of <code class="inline">define</code>, <code class="inline">generic</code>, and <code class="inline">fun</code>.</p>
<div class="code-wrapper"><code id="programming_head"><!-- Generated by codeUtils.js --></code></div>
<p>The type of a generic function, such as <code class="inline">head</code>, starts with its
type parameters surrounded by <code class="inline">&lt;</code> and <code class="inline">&gt;</code>.</p>
<p>Calling a generic function is just like calling a normal funtion,
most of the time. For example, the following invokes the
generic <code class="inline">length</code> function on an argument of type <code class="inline">List&lt;Nat&gt;</code>
and Deduce figures out that the type parameter <code class="inline">E</code> must be <code class="inline">Nat</code>.</p>
<div class="code-wrapper"><code id="programming_apply_length"><!-- Generated by codeUtils.js --></code></div>
<p>However, there are times when there is not enough information for
Deduce to determine the type parameters of a generic. For example,
both the <code class="inline">length</code> function and the <code class="inline">empty</code> constructor are generic, so
Deduce cannot figure out what type of list is being constructed in the
following.</p>
<div class="code-wrapper non-deduce"><code>assert&nbsp;length([])&nbsp;=&nbsp;0</code></div>
<p>Deduce responds with the error:</p>
<div class="code-wrapper non-deduce"><code>Cannot&nbsp;infer&nbsp;type&nbsp;arguments&nbsp;for<br>
&nbsp;&nbsp;&nbsp;&nbsp;[]<br>
Please&nbsp;make&nbsp;them&nbsp;explicit.</code></div>
<p>The solution is to explicitly instantiate either <code class="inline">empty</code> or <code class="inline">length</code>.
The syntax starts with <code class="inline">@</code>, followed by the generic entity, and finishes
with the type arguments surrounded by <code class="inline">&lt;</code> and <code class="inline">&gt;</code>. Here's the 
example again with the explicit instantiation.</p>
<div class="code-wrapper"><code id="programming_apply_length_empty"><!-- Generated by codeUtils.js --></code></div>
<h2 id="higher-order-functions">Higher-order Functions</h2>
<p>Functions may be passed as parameters to a function and they may be
returned from a function. For example, the following function checks
whether every element of a list satisfies a predicate.</p>
<div class="code-wrapper"><code id="programming_all_elements"><!-- Generated by codeUtils.js --></code></div>
<h2 id="pairs">Pairs</h2>
<p>Pairs are defined as a <code class="inline">union</code> type:</p>
<div class="code-wrapper"><code id="programming_Pair"><!-- Generated by codeUtils.js --></code></div>
<p>The file <code class="inline">Pair.pf</code> includes the above definition and several
operations on pairs, such as <code class="inline">first</code> and <code class="inline">second</code>.</p>
<h2 id="exercises">Exercises</h2>
<h3 id="sum-the-elements-in-a-list">Sum the Elements in a List</h3>
<p>Define a function named <code class="inline">sum</code> that adds up all the elements of a <code class="inline">List&lt;Nat&gt;</code>.</p>
<div class="code-wrapper"><code id="programming_test_sum"><!-- Generated by codeUtils.js --></code></div>
<h3 id="inner-product">Inner Product</h3>
<p>Define a function named <code class="inline">dot</code> that computes the inner product of two <code class="inline">List&lt;Nat&gt;</code>.</p>
<div class="code-wrapper"><code id="programming_test_dot"><!-- Generated by codeUtils.js --></code></div>
<h3 id="last-element-in-a-list">Last Element in a List</h3>
<p>Define a generic function named <code class="inline">last</code> that returns the last element
of a <code class="inline">List&lt;E&gt;</code>, if there is one. The return type should be <code class="inline">Option&lt;E&gt;</code>.
(<code class="inline">Option</code> is defined in the file <code class="inline">Option.pf</code>.)</p>
<div class="code-wrapper"><code id="programming_test_last"><!-- Generated by codeUtils.js --></code></div>
<h3 id="remove-elements-from-a-list">Remove Elements from a List</h3>
<p>Define a generic function named <code class="inline">remove_if</code> that removes elements
from a list if they satisfy a predicate. So <code class="inline">remove_if</code> should have two
parameters: (1) a <code class="inline">List&lt;E&gt;</code> and (2) a function whose parameter is <code class="inline">E</code> 
and whose return type is <code class="inline">bool</code>.</p>
<div class="code-wrapper"><code id="programming_test_remove_if"><!-- Generated by codeUtils.js --></code></div>
<h3 id="non-empty-lists-and-average">Non-empty Lists and Average</h3>
<p>Define a <code class="inline">union</code> type named <code class="inline">NEList</code> for non-empty list.  Design the
alternatives in the <code class="inline">union</code> carefuly to make it impossible to create
an empty list.</p>
<p>Define a function named <code class="inline">average</code> that computes the mean of a
non-empty list and check that it works on a few inputs.
Note that the second parameter of the division operator <code class="inline">/</code> 
is of type <code class="inline">Pos</code>, which is defined in <code class="inline">Nat.pf</code>.</p>
<!--

!!!{.deduce^file=FunctionalProgramming.pf}
&lt;&lt;ImportNat&gt;&gt;
&lt;&lt;five_six&gt;&gt;
&lt;&lt;print_five&gt;&gt;
&lt;&lt;area&gt;&gt;
&lt;&lt;print_area&gt;&gt;
&lt;&lt;NatList&gt;&gt;
&lt;&lt;NL12&gt;&gt;
&lt;&lt;List&gt;&gt;
&lt;&lt;L12&gt;&gt;
&lt;&lt;front&gt;&gt;
&lt;&lt;print_front&gt;&gt;
&lt;&lt;print7&gt;&gt;
&lt;&lt;assert_if_true&gt;&gt;
&lt;&lt;lenNatList&gt;&gt;
&lt;&lt;app&gt;&gt;
&lt;&lt;length&gt;&gt;
&lt;&lt;apply_length&gt;&gt;
&lt;&lt;apply_length_empty&gt;&gt;
&lt;&lt;head&gt;&gt;
&lt;&lt;all_elements&gt;&gt;
&lt;&lt;Pair&gt;&gt;
!!!


-->
        <deduce-footer>
            <!-- custom component defined in script.js -->
        </deduce-footer>
    </div>


    <script src="../js/cache.js"></script>
    <script src="../js/script.js"></script>
    <script src="../js/code.js"></script>
    <script src="../js/codeUtils.js"></script>
</body>

</html>
    